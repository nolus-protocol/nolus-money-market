{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "NeutronMsg",
  "description": "A number of Custom messages that can call into the Neutron bindings.",
  "oneOf": [
    {
      "description": "RegisterInterchainAccount registers an interchain account on remote chain.",
      "type": "object",
      "required": [
        "register_interchain_account"
      ],
      "properties": {
        "register_interchain_account": {
          "type": "object",
          "required": [
            "connection_id",
            "interchain_account_id"
          ],
          "properties": {
            "connection_id": {
              "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
              "type": "string"
            },
            "interchain_account_id": {
              "description": "**interchain_account_id** is an identifier of your new interchain account. Can be any string. This identifier allows contracts to have multiple interchain accounts on remote chains.",
              "type": "string"
            },
            "register_fee": {
              "description": "*register_fee** is a fees required to be payed to register interchain account",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/Coin"
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "SubmitTx starts the process of executing any Cosmos-SDK *msgs* on remote chain.",
      "type": "object",
      "required": [
        "submit_tx"
      ],
      "properties": {
        "submit_tx": {
          "type": "object",
          "required": [
            "connection_id",
            "fee",
            "interchain_account_id",
            "memo",
            "msgs",
            "timeout"
          ],
          "properties": {
            "connection_id": {
              "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
              "type": "string"
            },
            "fee": {
              "description": "**fee** is an ibc fee for the transaction.",
              "allOf": [
                {
                  "$ref": "#/definitions/IbcFee"
                }
              ]
            },
            "interchain_account_id": {
              "description": "*interchain_account_id** is an identifier of your interchain account from which you want to execute msgs.",
              "type": "string"
            },
            "memo": {
              "description": "*memo** is a memo you want to attach to your interchain transaction.It behaves like a memo in usual Cosmos transaction.",
              "type": "string"
            },
            "msgs": {
              "description": "*msgs** is a list of protobuf encoded Cosmos-SDK messages you want to execute on remote chain.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/ProtobufAny"
              }
            },
            "timeout": {
              "description": "*timeout** is a timeout in seconds after which the packet times out.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "RegisterInterchainQuery registers an interchain query.",
      "type": "object",
      "required": [
        "register_interchain_query"
      ],
      "properties": {
        "register_interchain_query": {
          "type": "object",
          "required": [
            "connection_id",
            "keys",
            "query_type",
            "transactions_filter",
            "update_period"
          ],
          "properties": {
            "connection_id": {
              "description": "*connection_id** is an IBC connection identifier between Neutron and remote chain.",
              "type": "string"
            },
            "keys": {
              "description": "*keys** is the KV-storage keys for which we want to get values from remote chain.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/KVKey"
              }
            },
            "query_type": {
              "description": "*query_type** is a query type identifier ('tx' or 'kv' for now).",
              "type": "string"
            },
            "transactions_filter": {
              "description": "*transactions_filter** is the filter for transaction search ICQ.",
              "type": "string"
            },
            "update_period": {
              "description": "*update_period** is used to say how often the query must be updated.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "RegisterInterchainQuery updates an interchain query.",
      "type": "object",
      "required": [
        "update_interchain_query"
      ],
      "properties": {
        "update_interchain_query": {
          "type": "object",
          "required": [
            "query_id"
          ],
          "properties": {
            "new_keys": {
              "description": "*new_keys** is the new query keys to retrive.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "$ref": "#/definitions/KVKey"
              }
            },
            "new_transactions_filter": {
              "description": "*new_transactions_filter** is a new transactions filter of the query.",
              "type": [
                "string",
                "null"
              ]
            },
            "new_update_period": {
              "description": "*new_update_period** is a new update period of the query.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "query_id": {
              "description": "*query_id** is the ID of the query we want to update.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "RemoveInterchainQuery removes as interchain query.",
      "type": "object",
      "required": [
        "remove_interchain_query"
      ],
      "properties": {
        "remove_interchain_query": {
          "type": "object",
          "required": [
            "query_id"
          ],
          "properties": {
            "query_id": {
              "description": "*query_id** is ID of the query we want to remove.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "IbcTransfer sends a fungible token packet over IBC.",
      "type": "object",
      "required": [
        "ibc_transfer"
      ],
      "properties": {
        "ibc_transfer": {
          "type": "object",
          "required": [
            "fee",
            "memo",
            "receiver",
            "sender",
            "source_channel",
            "source_port",
            "timeout_height",
            "timeout_timestamp",
            "token"
          ],
          "properties": {
            "fee": {
              "$ref": "#/definitions/IbcFee"
            },
            "memo": {
              "type": "string"
            },
            "receiver": {
              "type": "string"
            },
            "sender": {
              "type": "string"
            },
            "source_channel": {
              "type": "string"
            },
            "source_port": {
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/RequestPacketTimeoutHeight"
            },
            "timeout_timestamp": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "token": {
              "$ref": "#/definitions/Coin"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "SubmitAdminProposal sends a proposal to neutron's Admin module. This type of messages can be only executed by Neutron DAO.",
      "type": "object",
      "required": [
        "submit_admin_proposal"
      ],
      "properties": {
        "submit_admin_proposal": {
          "type": "object",
          "required": [
            "admin_proposal"
          ],
          "properties": {
            "admin_proposal": {
              "$ref": "#/definitions/AdminProposal"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactory message. Contracts can create denoms, namespaced under the contract's address. A contract may create any number of independent sub-denoms.",
      "type": "object",
      "required": [
        "create_denom"
      ],
      "properties": {
        "create_denom": {
          "type": "object",
          "required": [
            "subdenom"
          ],
          "properties": {
            "subdenom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactory message. Contracts can change the admin of a denom that they are the admin of.",
      "type": "object",
      "required": [
        "change_admin"
      ],
      "properties": {
        "change_admin": {
          "type": "object",
          "required": [
            "denom",
            "new_admin_address"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "new_admin_address": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactory message. Contracts can mint native tokens for an existing factory denom that they are the admin of.",
      "type": "object",
      "required": [
        "mint_tokens"
      ],
      "properties": {
        "mint_tokens": {
          "type": "object",
          "required": [
            "amount",
            "denom",
            "mint_to_address"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            },
            "mint_to_address": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactory message. Contracts can burn native tokens for an existing factory denom that they are the admin of. Currently, the burn from address must be the admin contract.",
      "type": "object",
      "required": [
        "burn_tokens"
      ],
      "properties": {
        "burn_tokens": {
          "type": "object",
          "required": [
            "amount",
            "burn_from_address",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "burn_from_address": {
              "description": "Must be set to `\"\"` for now",
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactory message. Contracts can set before send hooks for denoms, namespaced under the contract's address.",
      "type": "object",
      "required": [
        "set_before_send_hook"
      ],
      "properties": {
        "set_before_send_hook": {
          "type": "object",
          "required": [
            "contract_addr",
            "denom"
          ],
          "properties": {
            "contract_addr": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactoryMessage Contracts can force specified `amount` of an existing factory denom that they are admin of to a `transfer_to_address` from a `transfer_from_address`.",
      "type": "object",
      "required": [
        "force_transfer"
      ],
      "properties": {
        "force_transfer": {
          "type": "object",
          "required": [
            "amount",
            "denom",
            "transfer_from_address",
            "transfer_to_address"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            },
            "transfer_from_address": {
              "type": "string"
            },
            "transfer_to_address": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "TokenFactoryMessage Contracts can set a metadata for of an existing factory denom that they are admin of.",
      "type": "object",
      "required": [
        "set_denom_metadata"
      ],
      "properties": {
        "set_denom_metadata": {
          "type": "object",
          "required": [
            "base",
            "denom_units",
            "description",
            "display",
            "name",
            "symbol",
            "uri",
            "uri_hash"
          ],
          "properties": {
            "base": {
              "description": "*base** represents the base denom (should be the DenomUnit with exponent = 0).",
              "type": "string"
            },
            "denom_units": {
              "description": "*denom_units** represents the list of DenomUnit's for a given coin",
              "type": "array",
              "items": {
                "$ref": "#/definitions/DenomUnit"
              }
            },
            "description": {
              "description": "*description** description of a token",
              "type": "string"
            },
            "display": {
              "description": "**display** indicates the suggested denom that should be displayed in clients.",
              "type": "string"
            },
            "name": {
              "description": "*name** defines the name of the token (eg: Cosmos Atom)",
              "type": "string"
            },
            "symbol": {
              "description": "**symbol** is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display.",
              "type": "string"
            },
            "uri": {
              "description": "*uri** to a document (on or off-chain) that contains additional information. Optional.",
              "type": "string"
            },
            "uri_hash": {
              "description": "**uri_hash** is a sha256 hash of a document pointed by URI. It's used to verify that the document didn't change. Optional.",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "AddSchedule adds new schedule with a given `name`. Until schedule is removed it will execute all `msgs` every `period` blocks. First execution is at least on `current_block + period` block. [Permissioned - DAO Only]",
      "type": "object",
      "required": [
        "add_schedule"
      ],
      "properties": {
        "add_schedule": {
          "type": "object",
          "required": [
            "msgs",
            "name",
            "period"
          ],
          "properties": {
            "msgs": {
              "description": "list of cosmwasm messages to be executed",
              "type": "array",
              "items": {
                "$ref": "#/definitions/MsgExecuteContract"
              }
            },
            "name": {
              "description": "Name of a new schedule. Needed to be able to `RemoveSchedule` and to log information about it",
              "type": "string"
            },
            "period": {
              "description": "period in blocks with which `msgs` will be executed",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "RemoveSchedule removes the schedule with a given `name`. [Permissioned - DAO or Security DAO only]",
      "type": "object",
      "required": [
        "remove_schedule"
      ],
      "properties": {
        "remove_schedule": {
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Contractmanager message Resubmits failed acknowledgement. Acknowledgement failure is created when contract returns error or acknowledgement is out of gas. [Permissioned - only from contract that is initial caller of IBC transaction]",
      "type": "object",
      "required": [
        "resubmit_failure"
      ],
      "properties": {
        "resubmit_failure": {
          "type": "object",
          "required": [
            "failure_id"
          ],
          "properties": {
            "failure_id": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Dex messages",
      "type": "object",
      "required": [
        "dex"
      ],
      "properties": {
        "dex": {
          "$ref": "#/definitions/DexMsg"
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "AdminProposal": {
      "description": "AdminProposal defines the struct for various proposals which Neutron's Admin Module may accept.",
      "oneOf": [
        {
          "description": "Proposal to change params. Note that this works for old params. New params has their own `MsgUpdateParams` msgs that can be supplied to `ProposalExecuteMessage`",
          "type": "object",
          "required": [
            "param_change_proposal"
          ],
          "properties": {
            "param_change_proposal": {
              "$ref": "#/definitions/ParamChangeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to upgrade IBC client",
          "deprecated": true,
          "type": "object",
          "required": [
            "upgrade_proposal"
          ],
          "properties": {
            "upgrade_proposal": {
              "$ref": "#/definitions/UpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to update IBC client",
          "deprecated": true,
          "type": "object",
          "required": [
            "client_update_proposal"
          ],
          "properties": {
            "client_update_proposal": {
              "$ref": "#/definitions/ClientUpdateProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Proposal to execute CosmosMsg.",
          "type": "object",
          "required": [
            "proposal_execute_message"
          ],
          "properties": {
            "proposal_execute_message": {
              "$ref": "#/definitions/ProposalExecuteMessage"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to upgrade network",
          "deprecated": true,
          "type": "object",
          "required": [
            "software_upgrade_proposal"
          ],
          "properties": {
            "software_upgrade_proposal": {
              "$ref": "#/definitions/SoftwareUpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to cancel existing software upgrade",
          "deprecated": true,
          "type": "object",
          "required": [
            "cancel_software_upgrade_proposal"
          ],
          "properties": {
            "cancel_software_upgrade_proposal": {
              "$ref": "#/definitions/CancelSoftwareUpgradeProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Will fail to execute if you use it. Deprecated. Proposal to pin wasm contract codes",
          "deprecated": true,
          "type": "object",
          "required": [
            "pin_codes_proposal"
          ],
          "properties": {
            "pin_codes_proposal": {
              "$ref": "#/definitions/PinCodesProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Deprecated. Proposal to unpin wasm contract codes.",
          "deprecated": true,
          "type": "object",
          "required": [
            "unpin_codes_proposal"
          ],
          "properties": {
            "unpin_codes_proposal": {
              "$ref": "#/definitions/UnpinCodesProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to call sudo on contract.",
          "deprecated": true,
          "type": "object",
          "required": [
            "sudo_contract_proposal"
          ],
          "properties": {
            "sudo_contract_proposal": {
              "$ref": "#/definitions/SudoContractProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to update contract admin.",
          "deprecated": true,
          "type": "object",
          "required": [
            "update_admin_proposal"
          ],
          "properties": {
            "update_admin_proposal": {
              "$ref": "#/definitions/UpdateAdminProposal"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Deprecated. Proposal to clear contract admin.",
          "deprecated": true,
          "type": "object",
          "required": [
            "clear_admin_proposal"
          ],
          "properties": {
            "clear_admin_proposal": {
              "$ref": "#/definitions/ClearAdminProposal"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "CancelSoftwareUpgradeProposal": {
      "description": "Deprecated. CancelSoftwareUpgradeProposal defines the struct for cancel software upgrade proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ClearAdminProposal": {
      "description": "Deprecated. SudoContractProposal defines the struct for clear admin proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract admin will be removed.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ClientUpdateProposal": {
      "description": "ClientUpdateProposal defines the struct for client update proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "subject_client_id",
        "substitute_client_id",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "subject_client_id": {
          "description": "*subject_client_id** is a subject client id.",
          "type": "string"
        },
        "substitute_client_id": {
          "description": "*substitute_client_id** is a substitute client id.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "DenomUnit": {
      "description": "Replicates the cosmos-sdk bank module DenomUnit type",
      "type": "object",
      "required": [
        "aliases",
        "denom",
        "exponent"
      ],
      "properties": {
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "denom": {
          "type": "string"
        },
        "exponent": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "DepositOption": {
      "type": "object",
      "required": [
        "disable_swap"
      ],
      "properties": {
        "disable_swap": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "DexMsg": {
      "oneOf": [
        {
          "description": "Deposit provides liquidity to a specific trading pair by depositing tokens at a specific price into one or both sides of the pair in “a liquidity pool”",
          "type": "object",
          "required": [
            "deposit"
          ],
          "properties": {
            "deposit": {
              "type": "object",
              "required": [
                "amounts_a",
                "amounts_b",
                "fees",
                "options",
                "receiver",
                "tick_indexes_a_to_b",
                "token_a",
                "token_b"
              ],
              "properties": {
                "amounts_a": {
                  "description": "Amounts of tokenA to deposit",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "amounts_b": {
                  "description": "Amounts of tokenB to deposit",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "fees": {
                  "description": "Fees to use for each deposit",
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                },
                "options": {
                  "description": "Additional deposit options",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/DepositOption"
                  }
                },
                "receiver": {
                  "description": "The account to which PoolShares will be issued",
                  "type": "string"
                },
                "tick_indexes_a_to_b": {
                  "description": "Tick indexes to deposit at defined in terms of TokenA to TokenB (ie. TokenA is on the left)",
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "int64"
                  }
                },
                "token_a": {
                  "description": "Denom for one side of the deposit",
                  "type": "string"
                },
                "token_b": {
                  "description": "Denom for the opposing side of the deposit",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Withdraw is used to redeem PoolShares for the user’s pro-rata portion of tokens within a liquidity pool. Users can withdraw from a pool at any time",
          "type": "object",
          "required": [
            "withdrawal"
          ],
          "properties": {
            "withdrawal": {
              "type": "object",
              "required": [
                "fees",
                "receiver",
                "shares_to_remove",
                "tick_indexes_a_to_b",
                "token_a",
                "token_b"
              ],
              "properties": {
                "fees": {
                  "description": "Fee for the target LiquidityPools",
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                },
                "receiver": {
                  "description": "The account to which the tokens are credited",
                  "type": "string"
                },
                "shares_to_remove": {
                  "description": "Amount of shares to remove from each pool",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Uint128"
                  }
                },
                "tick_indexes_a_to_b": {
                  "description": "Tick indexes of the target LiquidityPools defined in terms of TokenA to TokenB (ie. TokenA is on the left)",
                  "type": "array",
                  "items": {
                    "type": "integer",
                    "format": "int64"
                  }
                },
                "token_a": {
                  "description": "Denom for one side of the deposit",
                  "type": "string"
                },
                "token_b": {
                  "description": "Denom for the opposing side of the deposit",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "PlaceLimitOrder provides the primary mechanism for trading on the Duality Dex. Limit orders can provide liquidity to the Dex (“Maker Limit Orders”) and/or can be used to trade against preexisting liquidity (“Taker Limit Orders”)",
          "type": "object",
          "required": [
            "place_limit_order"
          ],
          "properties": {
            "place_limit_order": {
              "type": "object",
              "required": [
                "amount_in",
                "limit_sell_price",
                "order_type",
                "receiver",
                "tick_index_in_to_out",
                "token_in",
                "token_out"
              ],
              "properties": {
                "amount_in": {
                  "description": "Amount of TokenIn to be traded",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Uint128"
                    }
                  ]
                },
                "expiration_time": {
                  "description": "Expiration time for order. Only valid for GOOD_TIL_TIME limit orders",
                  "type": [
                    "integer",
                    "null"
                  ],
                  "format": "uint64",
                  "minimum": 0.0
                },
                "limit_sell_price": {
                  "description": "Accepts standard decimals and decimals with scientific notation (ie. 1234.23E-7)",
                  "type": "string"
                },
                "max_amount_out": {
                  "description": "Maximum amount of TokenB can be bought. For everything except JUST_IN_TIME OrderType",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/Uint128"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "order_type": {
                  "description": "Type of limit order to be used. Must be one of: GOOD_TIL_CANCELLED, FILL_OR_KILL, IMMEDIATE_OR_CANCEL, JUST_IN_TIME, or GOOD_TIL_TIME",
                  "allOf": [
                    {
                      "$ref": "#/definitions/LimitOrderType"
                    }
                  ]
                },
                "receiver": {
                  "description": "Account to which TokenOut is credited or that will be allowed to withdraw or cancel a maker order",
                  "type": "string"
                },
                "tick_index_in_to_out": {
                  "description": "Limit tick for a limit order, specified in terms of TokenIn to TokenOut",
                  "type": "integer",
                  "format": "int64"
                },
                "token_in": {
                  "description": "Token being “sold”",
                  "type": "string"
                },
                "token_out": {
                  "description": "Token being “bought”",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "WithdrawFilledLimitOrder. Once a limit order has been filled – either partially or in its entirety, it can be withdrawn at any time. Withdrawing from a limit order credits all available proceeds to the user. Withdraw can be called on a limit order multiple times as new proceeds become available",
          "type": "object",
          "required": [
            "withdraw_filled_limit_order"
          ],
          "properties": {
            "withdraw_filled_limit_order": {
              "type": "object",
              "required": [
                "tranche_key"
              ],
              "properties": {
                "tranche_key": {
                  "description": "TrancheKey for the target limit order",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "CancelLimitOrder. Standard Taker limit orders (Good-til-cancelled & Good-til-Time) can be canceled at any time if they have not been completely filled",
          "type": "object",
          "required": [
            "cancel_limit_order"
          ],
          "properties": {
            "cancel_limit_order": {
              "type": "object",
              "required": [
                "tranche_key"
              ],
              "properties": {
                "tranche_key": {
                  "description": "TrancheKey for the target limit order",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "MultiHopSwap provides a swapping mechanism to achieve better prices by routing through a series of pools",
          "type": "object",
          "required": [
            "multi_hop_swap"
          ],
          "properties": {
            "multi_hop_swap": {
              "type": "object",
              "required": [
                "amount_in",
                "exit_limit_price",
                "pick_best_route",
                "receiver",
                "routes"
              ],
              "properties": {
                "amount_in": {
                  "description": "Amount of TokenIn to swap",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Uint128"
                    }
                  ]
                },
                "exit_limit_price": {
                  "description": "Minimum price that that must be satisfied for a route to succeed",
                  "allOf": [
                    {
                      "$ref": "#/definitions/PrecDec"
                    }
                  ]
                },
                "pick_best_route": {
                  "description": "If true all routes are run and the route with the best price is used",
                  "type": "boolean"
                },
                "receiver": {
                  "description": "Account to which TokenOut is credited",
                  "type": "string"
                },
                "routes": {
                  "description": "Array of possible routes",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/MultiHopRoute"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "IbcFee": {
      "description": "IbcFee defines struct for fees that refund the relayer for `SudoMsg` messages submission. Unused fee kind will be returned back to message sender. Please refer to these links for more information: IBC transaction structure - <https://docs.neutron.org/neutron/interchain-txs/messages/#msgsubmittx> General mechanics of fee payments - <https://docs.neutron.org/neutron/feerefunder/overview/#general-mechanics>",
      "type": "object",
      "required": [
        "ack_fee",
        "recv_fee",
        "timeout_fee"
      ],
      "properties": {
        "ack_fee": {
          "description": "*ack_fee** is an amount of coins to refund relayer for submitting ack message for a particular IBC packet.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "recv_fee": {
          "description": "**recv_fee** currently is used for compatibility with ICS-29 interface only and must be set to zero (i.e. 0untrn), because Neutron's fee module can't refund relayer for submission of Recv IBC packets due to compatibility with target chains.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "timeout_fee": {
          "description": "*timeout_fee** amount of coins to refund relayer for submitting timeout message for a particular IBC packet.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        }
      },
      "additionalProperties": false
    },
    "KVKey": {
      "description": "Describes a KV key for which you want to get value from the storage on remote chain",
      "type": "object",
      "required": [
        "key",
        "path"
      ],
      "properties": {
        "key": {
          "description": "*key** is a key you want to read from the storage",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "path": {
          "description": "*path** is a path to the storage (storage prefix) where you want to read value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "LimitOrderType": {
      "oneOf": [
        {
          "description": "Good-til-Cancelled limit orders are hybrid maker and taker limit orders. They will attempt to trade the supplied AmountIn at the TickIndex or better. However, if they total AmountIn cannot be traded at the limit price they are remaining amount will be placed as a maker limit order. The proceeds from the taker portion are deposited into the user’s account immediately, however, the proceeds from the maker portion must be explicitly withdrawn via WithdrawLimitOrder.",
          "type": "string",
          "enum": [
            "GOOD_TIL_CANCELLED"
          ]
        },
        {
          "description": "Fill-or-Kill limit orders are taker limit orders that either successfully swap 100% of the supplied AmountIn or return an error. If there is insufficient liquidity to complete the trade at or above the supplied TickIndex a Fill-or-Kill order will return an error `codespace: dex, code: 1134` (<https://github.com/neutron-org/neutron/blob/main/x/dex/types/errors.go#L107> ErrGoodTilOrderWithoutExpiration).",
          "type": "string",
          "enum": [
            "FILL_OR_KILL"
          ]
        },
        {
          "description": "Immediate-or-Cancel limit orders are taker orders that will swap as much as of the AmountIn as possible given available liquidity above the supplied TickIndex. Unlike Fill-or-Kill orders they will still successfully complete even if they are only able to partially trade through the AmountIn at the TickIndex or better.",
          "type": "string",
          "enum": [
            "IMMEDIATE_OR_CANCEL"
          ]
        },
        {
          "description": "Just-in-Time limit orders are an advanced maker limit order that provides tradeable liquidity for exactly one block. At the end of the same block in which the Just-in-Time order was submitted the order is canceled and any untraded portion will no longer be usable as active liquidity.",
          "type": "string",
          "enum": [
            "JUST_IN_TIME"
          ]
        },
        {
          "description": "Good-til-Time limit order function exactly the same as Good-til-Cancelled limit orders first trying to trade as a taker limit order and then placing any remaining amount as a maker limit order. However, the maker portion of the limit order has a specified ExpirationTime. After the ExpirationTime the order will be cancelled and can no longer be traded against. When withdrawing a Good-til-Time limit order the user will receive both the successfully traded portion of the limit order (TokenOut) as well as any remaining untraded amount (TokenIn).",
          "type": "string",
          "enum": [
            "GOOD_TIL_TIME"
          ]
        }
      ]
    },
    "MsgExecuteContract": {
      "description": "MsgExecuteContract defines a call to the contract execution",
      "type": "object",
      "required": [
        "contract",
        "msg"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is a contract address that will be called",
          "type": "string"
        },
        "msg": {
          "description": "*msg** is a contract call message",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "MultiHopRoute": {
      "type": "object",
      "required": [
        "hops"
      ],
      "properties": {
        "hops": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "ParamChange": {
      "description": "ParamChange defines the struct for parameter change request.",
      "type": "object",
      "required": [
        "key",
        "subspace",
        "value"
      ],
      "properties": {
        "key": {
          "description": "*key** is a name of parameter. Unique for subspace.",
          "type": "string"
        },
        "subspace": {
          "description": "*subspace** is a key of module to which the parameter to change belongs. Unique for each module.",
          "type": "string"
        },
        "value": {
          "description": "*value** is a new value for given parameter. Non unique.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ParamChangeProposal": {
      "description": "ParamChangeProposal defines the struct for single parameter change proposal.",
      "type": "object",
      "required": [
        "description",
        "param_changes",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "param_changes": {
          "description": "*param_changes** is a vector of params to be changed. Non unique.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ParamChange"
          }
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PinCodesProposal": {
      "description": "Deprecated. PinCodesProposal defines the struct for pin contract codes proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "code_ids",
        "description",
        "title"
      ],
      "properties": {
        "code_ids": {
          "description": "*code_ids** is an array of codes to be pined.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Plan": {
      "description": "Plan defines the struct for planned upgrade.",
      "type": "object",
      "required": [
        "height",
        "info",
        "name"
      ],
      "properties": {
        "height": {
          "description": "*height** is a height at which the upgrade must be performed",
          "type": "integer",
          "format": "int64"
        },
        "info": {
          "description": "*info** is any application specific upgrade info to be included on-chain",
          "type": "string"
        },
        "name": {
          "description": "*name** is a name for the upgrade",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "PrecDec": {
      "type": "object",
      "required": [
        "i"
      ],
      "properties": {
        "i": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ProposalExecuteMessage": {
      "description": "ProposalExecuteMessage defines the struct for sdk47 compatible admin proposal.",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "*message** is a json representing an sdk message passed to admin module to execute.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ProtobufAny": {
      "description": "Type for wrapping any protobuf message",
      "type": "object",
      "required": [
        "type_url",
        "value"
      ],
      "properties": {
        "type_url": {
          "description": "*type_url** describes the type of the serialized message",
          "type": "string"
        },
        "value": {
          "description": "*value** must be a valid serialized protocol buffer of the above specified type",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "RequestPacketTimeoutHeight": {
      "type": "object",
      "properties": {
        "revision_height": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "revision_number": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "SoftwareUpgradeProposal": {
      "description": "Deprecated. SoftwareUpgradeProposal defines the struct for software upgrade proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "plan",
        "title"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal. Non unique.",
          "type": "string"
        },
        "plan": {
          "description": "*plan** is a plan of upgrade.",
          "allOf": [
            {
              "$ref": "#/definitions/Plan"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal. Non unique.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SudoContractProposal": {
      "description": "Deprecated. SudoContractProposal defines the struct for sudo execution proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "msg",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract to be executed.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "msg": {
          "description": "**msg*** is a sudo message.",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "UnpinCodesProposal": {
      "description": "Deprecated. UnpinCodesProposal defines the struct for unpin contract codes proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "code_ids",
        "description",
        "title"
      ],
      "properties": {
        "code_ids": {
          "description": "*code_ids** is an array of codes to be unpined.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "UpdateAdminProposal": {
      "description": "Deprecated. UpdateAdminProposal defines the struct for update admin proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "contract",
        "description",
        "new_admin",
        "title"
      ],
      "properties": {
        "contract": {
          "description": "*contract** is an address of contract to update admin.",
          "type": "string"
        },
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "new_admin": {
          "description": "**new_admin*** is an address of new admin",
          "type": "string"
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "UpgradeProposal": {
      "description": "UpgradeProposal defines the struct for IBC upgrade proposal.",
      "deprecated": true,
      "type": "object",
      "required": [
        "description",
        "plan",
        "title",
        "upgraded_client_state"
      ],
      "properties": {
        "description": {
          "description": "*description** is a text description of proposal.",
          "type": "string"
        },
        "plan": {
          "description": "*plan** is a plan of upgrade.",
          "allOf": [
            {
              "$ref": "#/definitions/Plan"
            }
          ]
        },
        "title": {
          "description": "*title** is a text title of proposal.",
          "type": "string"
        },
        "upgraded_client_state": {
          "description": "*upgraded_client_state** is an upgraded client state.",
          "allOf": [
            {
              "$ref": "#/definitions/ProtobufAny"
            }
          ]
        }
      },
      "additionalProperties": false
    }
  }
}
